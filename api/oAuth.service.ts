/**
 * Nexus OAuth API
 * This is an API entirely made and managed by [Nexus Company](https://nexus-company.net).    # Authentication  This API uses a secure authentication method divided into two steps with the last resulting in JWT,  ## Authenticated Request  Post OAuth authorization use your access token on \"Authorization\" header for routes where authentication is required.  > The header format should be as follows: \"{Token Type} {JWT Access Token}\"  > example: \"Barear AAAAAAAAAAAAAAAAAAA\"    #### Example  This example shows one http request for get user account.    ```http  GET /api/Accounts/MyAccount HTTP/1.1  Host: auth.nexus-company.net  Authorization: Barear AAAAAAAAAAAAAAAA  User-Agent: ExampleClient 1.0    -- EMPTY BODY (FOR EXAMPLE)  ```    ### First step of authentication    Send a `GET` request to the [`/api/Authentications/FirstStep`]() route.  1. Include the following headers in the request:       - `User-Agent`: Identifies the user agent.       - `Client-Key`: Client key for authentication.  2. Include the following parameters in the query string:       - `user`: Username or email.       - `hCaptchaToken`: Token generated by hCaptcha.    > The `hCaptchaToken` value is obtained by the HCaptcha API, see the documentation for this API [here](https://docs.hcaptcha.com/).    3. The request response will be JSON with the following format:    ```json  {      \"id\": 0,      \"date\": \"2024-02-28T22:18:22.819Z\",      \"userAgent\": \"string\",      \"token\": \"string\",      \"expiresIn\": 0,      \"userName\": \"string\",      \"profileImage\": {          \"fileName\": \"string\",          \"type\": \"Image\",          \"length\": 0,          \"resourceType\": \"ApplicationLogo\",          \"url\": \"string\"      }  }  ```            4. Store the `Id` of this request for the next step    > The token generated by this step has a limited validity, after its expiration it will be necessary to obtain it again.    ### Second step of authentication    Now send a `GET` request to the route [`/api/Authentications/SecondStep `](#operations-Authentications-get_api_Authentications_SecondStep).  2. Include the following parameters in the query string:       - `pwd`: User password.       - `token`: Token from Google Authenticator or another similar application.       - `fs_id`: The `Id` value obtained in the first step.  3. The request response will be JSON with the following format:  ```json  {    \"token\": \"string\",    \"expiresIn\": \"2024-02-28T22:49:12.559Z\",    \"refreshToken\": \"string\",    \"type\": \"Bearer\"  }  ```  4. Store the returned JWT token in the `token` field for use in subsequent API requests.    > The JWT token generated in the second step has limited validity. You will need to redo the authentication process after the token expires or you can send a POST request to [`/api/Authentications/Refresh `](#operations-Authentications-post_api_Authentications_Refresh). where you will get a new JWT token.    > **Additional Step**  If the user has two-factor authentication activated on their account, two new API calls may be necessary, which will be documented shortly when the process is fully developed.    ### Login example  First step request  ```curl  curl -X GET\\  -H \"User-Agent: ExampleClient 1.0\" \\  -H \"Client-Key: 1234567890\" \\  -d \"user=johndoe@gmail.com\" \\  -d \"hCaptchaToken=0xdeadbeef\" \\  \"https://oauth-api.nexus-company.net/api/Authentications/FirstStep\"  ```  Second step request  ```curl  curl -X GET\\  -d \"pwd=secretpassword\" \\  -d \"token=0xdeadbeef\" \\  -d \"fs_id=1234567890\" \\  \"https://oauth-api.nexus-company.net/api/Authentications/SecondStep\"
 *
 * OpenAPI spec version: v1
 * Contact: juandouglas2004@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { AuthenticationResult } from '../model/authenticationResult';
import { GrantType } from '../model/grantType';
import { ProblemDetails } from '../model/problemDetails';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class OAuthService {

    protected basePath = '/';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * 
     * 
     * @param grantType 
     * @param clientId 
     * @param clientSecret 
     * @param userAgent 
     * @param code 
     * @param redirectUri 
     * @param scope 
     * @param refreshToken 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiOAuthAccessTokenGet(grantType: GrantType, clientId: string, clientSecret: string, userAgent?: string, code?: string, redirectUri?: string, scope?: string, refreshToken?: string, observe?: 'body', reportProgress?: boolean): Observable<AuthenticationResult>;
    public apiOAuthAccessTokenGet(grantType: GrantType, clientId: string, clientSecret: string, userAgent?: string, code?: string, redirectUri?: string, scope?: string, refreshToken?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AuthenticationResult>>;
    public apiOAuthAccessTokenGet(grantType: GrantType, clientId: string, clientSecret: string, userAgent?: string, code?: string, redirectUri?: string, scope?: string, refreshToken?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AuthenticationResult>>;
    public apiOAuthAccessTokenGet(grantType: GrantType, clientId: string, clientSecret: string, userAgent?: string, code?: string, redirectUri?: string, scope?: string, refreshToken?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (grantType === null || grantType === undefined) {
            throw new Error('Required parameter grantType was null or undefined when calling apiOAuthAccessTokenGet.');
        }

        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling apiOAuthAccessTokenGet.');
        }

        if (clientSecret === null || clientSecret === undefined) {
            throw new Error('Required parameter clientSecret was null or undefined when calling apiOAuthAccessTokenGet.');
        }






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (grantType !== undefined && grantType !== null) {
            queryParameters = queryParameters.set('grant_type', <any>grantType);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('client_id', <any>clientId);
        }
        if (clientSecret !== undefined && clientSecret !== null) {
            queryParameters = queryParameters.set('client_secret', <any>clientSecret);
        }
        if (code !== undefined && code !== null) {
            queryParameters = queryParameters.set('code', <any>code);
        }
        if (redirectUri !== undefined && redirectUri !== null) {
            queryParameters = queryParameters.set('redirect_uri', <any>redirectUri);
        }
        if (scope !== undefined && scope !== null) {
            queryParameters = queryParameters.set('scope', <any>scope);
        }
        if (refreshToken !== undefined && refreshToken !== null) {
            queryParameters = queryParameters.set('refresh_token', <any>refreshToken);
        }

        let headers = this.defaultHeaders;
        if (userAgent !== undefined && userAgent !== null) {
            headers = headers.set('User-Agent', String(userAgent));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AuthenticationResult>('get',`${this.basePath}/api/OAuth/AccessToken`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param clientId 
     * @param scope 
     * @param redirectUri 
     * @param state 
     * @param applicationId 
     * @param autoRedirect 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiOAuthAuthorizeGet(clientId?: string, scope?: string, redirectUri?: string, state?: string, applicationId?: string, autoRedirect?: boolean, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public apiOAuthAuthorizeGet(clientId?: string, scope?: string, redirectUri?: string, state?: string, applicationId?: string, autoRedirect?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public apiOAuthAuthorizeGet(clientId?: string, scope?: string, redirectUri?: string, state?: string, applicationId?: string, autoRedirect?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public apiOAuthAuthorizeGet(clientId?: string, scope?: string, redirectUri?: string, state?: string, applicationId?: string, autoRedirect?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('client_id', <any>clientId);
        }
        if (scope !== undefined && scope !== null) {
            queryParameters = queryParameters.set('scope', <any>scope);
        }
        if (redirectUri !== undefined && redirectUri !== null) {
            queryParameters = queryParameters.set('redirect_uri', <any>redirectUri);
        }
        if (state !== undefined && state !== null) {
            queryParameters = queryParameters.set('state', <any>state);
        }
        if (applicationId !== undefined && applicationId !== null) {
            queryParameters = queryParameters.set('application_id', <any>applicationId);
        }
        if (autoRedirect !== undefined && autoRedirect !== null) {
            queryParameters = queryParameters.set('autoRedirect', <any>autoRedirect);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('get',`${this.basePath}/api/OAuth/Authorize`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param scopes 
     * @param grantType 
     * @param code 
     * @param age 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiOAuthOIDCAccessTokenPostForm(scopes: string, grantType?: GrantType, code?: string, age?: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public apiOAuthOIDCAccessTokenPostForm(scopes: string, grantType?: GrantType, code?: string, age?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public apiOAuthOIDCAccessTokenPostForm(scopes: string, grantType?: GrantType, code?: string, age?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public apiOAuthOIDCAccessTokenPostForm(scopes: string, grantType?: GrantType, code?: string, age?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (scopes === null || scopes === undefined) {
            throw new Error('Required parameter scopes was null or undefined when calling apiOAuthOIDCAccessTokenPost.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (scopes !== undefined && scopes !== null) {
            queryParameters = queryParameters.set('scopes', <any>scopes);
        }
        if (age !== undefined && age !== null) {
            queryParameters = queryParameters.set('age', <any>age);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (grantType !== undefined) {
            formParams = formParams.append('grant_type', <any>grantType) as any || formParams;
        }
        if (code !== undefined) {
            formParams = formParams.append('code', <any>code) as any || formParams;
        }

        return this.httpClient.request<any>('post',`${this.basePath}/api/OAuth/OIDC/AccessToken`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param clientId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiOAuthRevokePost(clientId?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public apiOAuthRevokePost(clientId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public apiOAuthRevokePost(clientId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public apiOAuthRevokePost(clientId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('client_id', <any>clientId);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('post',`${this.basePath}/api/OAuth/Revoke`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
